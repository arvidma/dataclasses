# InitVar type extraction differs from CPython 3.8

## Severity: LOW

## Description

The backport extracts the inner type from `InitVar[T]` and sets
`f.type` to `T`. CPython 3.8 does **not** do this - it keeps
`f.type` as the full `InitVar[T]` instance. CPython added this
extraction starting in 3.12+.

## Code (dataclasses.py, _get_field)

```python
# If the type is InitVar[T], extract the inner type so that
# f.type is T rather than InitVar[T].
if type(a_type) is InitVar:
    f.type = a_type.type
```

## Impact

Code inspecting `field.type` for InitVar fields sees the unwrapped
type (`int`) instead of `InitVar[int]`. This only affects internal
code or direct access to `cls.__dataclass_fields__`, since `fields()`
filters out InitVar fields. The `__init__` signature also shows
the clean type annotation (`x: int`) rather than `x: InitVar[int]`.

The behavior matches CPython 3.12+ and produces cleaner signatures.

## Sources

- CPython 3.8 `Lib/dataclasses.py`, `_get_field()`
- CPython 3.12 `Lib/dataclasses.py`, `_get_field()`
- bpo-33569: https://bugs.python.org/issue33569

## Resolution

This is an intentional design choice matching CPython 3.12+ rather
than 3.8. Updated the comment in code to clarify this. Also removed
the redundant `f._field_type is _FIELD_INITVAR` check (we just set
it on the line above, so it is always true).
