# replace() for InitVar with defaults - structurally different from CPython

## Severity: LOW

## Description

The backport's `replace()` handled InitVar fields with default values
using a structurally different approach than CPython. While functionally
equivalent in most cases, the mechanism diverged.

## Original code (dataclasses.py)

```python
if f.name not in changes:
    if f._field_type is _FIELD_INITVAR:
        if f.default is MISSING and f.default_factory is MISSING:
            raise ValueError(
                f"InitVar {f.name!r} must be specified with replace()"
            )
        # InitVar with default: falls through, does NOTHING
    else:
        changes[f.name] = getattr(obj, f.name)
```

Two issues:
1. The `default_factory` check is dead code - InitVar fields can never
   have `default_factory` (enforced at class creation time).
2. The `else` branch prevents `getattr` for InitVar fields with
   defaults. In CPython, `getattr(obj, f.name)` runs for ALL fields
   that pass the raise check, including InitVar fields with defaults.

## CPython (3.8.12+ / 3.10+ / 3.12+ / 3.14, reference)

```python
if f.name not in changes:
    if f._field_type is _FIELD_INITVAR and f.default is MISSING:
        raise ValueError(f"InitVar {f.name!r} "
                         'must be specified with replace()')
    changes[f.name] = getattr(obj, f.name)
```

## Sources

- CPython Issue: https://github.com/python/cpython/issues/80651
- BPO-36470: https://bugs.python.org/issue36470
- CPython 3.12 `Lib/dataclasses.py`, `replace()`

## Resolution

Changed to match CPython exactly: removed the redundant
`default_factory` check and the `else` branch, so `getattr` now runs
for all fields including InitVar fields with defaults. This also
resolves issue 7 (redundant `default_factory` check).
